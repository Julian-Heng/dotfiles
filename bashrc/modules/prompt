##################
##### Prompt #####
##################
# shellcheck disable=2148,2154

function prompter
{
    function __get_git_branch
    {
        case "$1" in
            *"No commits"*)
                : NA
            ;;

            *"no branch"*)
                : "${i%%\(*}"
                : "${_//#}"
                : "${_//[[:space:]]}"
            ;;

            *)
                : "${i%%\.*}"
                : "${_//#}"
                : "${_//[[:space:]]}"
            ;;
        esac
        printf "%s" "${_}"
    }

    function _git_prompt
    {
        local git_prompt
        local _git_branch
        local _git_status
        local _git_status_clear
        local num_staged
        local num_changed
        local num_conflicts
        local num_untracked

        unset _git_status
        unset num_stages
        unset num_changed
        unset num_conflicts
        unset num_untracked

        # Git status symbols and algorithm referenced from
        #   - https://github.com/magicmonty/bash-git-prompt/blob/master/gitstatus.sh
        #   - https://git-scm.com/docs/git-status

        { [[ -d ".git" ]] || git rev-parse --git-dir > /dev/null 2>&1; } && {
            while IFS=$'\n' read -r i; do
                status="${i:0:2}"
                while [[ -n "${status}" ]]; do
                    case "${status}" in
                        "##")
                            _git_branch="$(__get_git_branch "${i}")"
                            break
                        ;;
                        "??")       ((num_untracked++)); break ;;
                        "U"?|?"U"|\
                        "DD"|"AA")  ((num_conflicts++)); break ;;
                        ?"M"|?"D")  ((num_changed++)) ;;
                        ?" ") ;;
                        "U")        ((num_conflicts++)) ;;
                        " ") ;;
                        *)          ((num_staged++)) ;;
                    esac
                    status="${status:0:(${#status}-1)}"
                done
            done < <(git status --porcelain --branch)

            ((num_conflicts == 0 && \
            num_changed == 0 && \
            num_staged == 0 && \
            num_untracked == 0 )) && \
                _git_status_clear="true"

            ((num_conflicts > 0)) && \
                _git_status+="${f[1]}✖${num_conflicts}${reset}"
            ((num_changed > 0)) && \
                _git_status+="${f[4]}✚${num_changed}${reset}"
            ((num_staged > 0)) && \
                _git_status+="${f[6]}●${num_staged}${reset}"
            ((num_untracked > 0)) && \
                _git_status+="${bold}…${num_untracked}${reset}"

            if [[ "${_git_status_clear}" == "true" ]]; then
                git_prompt="-[${c2}${_git_branch}${reset}]"
            else
                git_prompt="-[${c2}${_git_branch}${reset}|${_git_status}]"
            fi
        }

        printf "%s" "${git_prompt}"
    }

    function expand
    {
        local str="$1"
        mapfile -t out <<< "${str}"
        printf "%s" "${out[@]}"
    }

    function dir
    {
        local _PWD
        local -a parts

        unset _PWD
        : "${PWD}"
        : "${_//${HOME}/"~"}"

        IFS="/"\
        read -r -a parts <<< "${_}"

        for part in "${parts[@]::${#parts[@]}-1}"; do
            count="0"
            for in_part in $(expand "${part}"); do
                if ((count == 0)); then
                    if [[ "${in_part:0:1}" == "." ]]; then
                        : "/${in_part:0:2}"
                    else
                        : "/${in_part:0:1}"
                    fi
                    ((count++))
                else
                    : "${in_part:0:1}"
                fi
                _PWD+="${_}"
            done
        done

        _PWD+="/${parts[-1]}"
        [[ "${_PWD:1:1}" == "~" ]] && _PWD="${_PWD#/}"

        ((${#_PWD} > 20)) && _PWD="${parts[-1]}"

        printf "%s" "${_PWD:-"/"}"
    }

    unset prompt_line PS1
 
    c1="${fb[2]}"
    c2="${fb[4]}"

    prompt_line+=("${c1}\\u${reset}@${c1}\\h${reset}: (${c2}$(dir)${reset})$(_git_prompt)\\n")
    prompt_line+=("\\$ ")

    for i in "${prompt_line[@]}"; do
        PS1+="${i}"
    done

    export PS1
}

PROMPT_COMMAND=prompter
