#!/usr/bin/env -S python3 -B
# vim: syntax=python

from abc import ABC, abstractmethod
from os import chdir, devnull
from pathlib import Path
from re import findall
from shutil import get_terminal_size
from subprocess import call, PIPE, run
from sys import argv, stdout
from typing import List, Tuple, Callable


class Git(ABC):

    @staticmethod
    def get_runner():
        cmd = ["git", "--version"]
        keys = ["major", "minor", "patch"]
        vals = [int(i) for i in findall(r"\d+", run_cmd(cmd)[1])]
        version = dict(zip(keys, vals))
        check = lambda i: i["major"] == 1 and i["minor"] == 8 and i["patch"] < 5
        return GitRunnerOld() if check(version) else GitRunnerNew()

    def is_repo(self, path: Path) -> bool:
        check = lambda p: p.exists() and p.is_dir()
        return (check(Path("{}/.git".format(path))) or
                len(self.rev_parse(path, ["--git-dir"]).split("\n")) > 0)

    @abstractmethod
    def fetch(self, path: Path) -> int:
        pass

    @abstractmethod
    def pull(self, path: Path) -> int:
        pass

    @abstractmethod
    def rev_parse(self, path: Path, args: List[str]) -> str:
        pass


class GitRunnerNew(Git):

    def fetch(self, path: Path) -> int:
        return call(["git", "-C", path, "fetch", "--quiet"])

    def pull(self, path: Path) -> int:
        return call(["git", "-C", path, "pull"])

    def rev_parse(self, path: Path, args: List[str]) -> str:
        return run_cmd(["git", "-C", str(path), "rev-parse"] + args)[1]


class GitRunnerOld(Git):

    def _execute_in_dir(self, path: Path, func: Callable, *args, **kwargs):
        prev_cwd = Path.cwd()
        try:
            chdir(str(path))
            return func(*args, **kwargs)
        except NotADirectoryError:
            pass
        finally:
            chdir(str(prev_cwd))

    def fetch(self, path: Path) -> int:
        cmd = ["git", "fetch", "--quiet"]
        return self._execute_in_dir(path, call, cmd)

    def pull(self, path: Path) -> int:
        cmd = ["git", "pull"]
        return self._execute_in_dir(path, call, cmd)

    def rev_parse(self, path: Path, args: List[str]) -> str:
        cmd = ["git", "rev-parse"] + args
        ret = self._execute_in_dir(path, run_cmd, cmd)
        return ret[1] if ret else None


def run_cmd(cmd: List[str]) -> Tuple[int, str]:
    out = PIPE
    err = open(devnull, "w")
    proc = run(cmd, stdout=out, stderr=err)
    return proc.returncode, proc.stdout.decode("utf-8").strip()


def main():
    repos = dict()
    git = Git.get_runner()

    paths = argv[1:] if argv[1:] else ["."]

    for i in paths:
        for j in Path(i).glob("*"):
            repo_path = git.rev_parse(j, ["--show-toplevel"])
            if repo_path:
                if repo_path in repos:
                    break
                elif git.is_repo(j):
                    repos[repo_path] = "1"

    repos = sorted(repos.keys())

    for i in repos:
        cols, _ = get_terminal_size(fallback=(80, 0))

        print("Updating {}... ".format(i), end="", flush=True)

        git.fetch(i)
        local_ref = git.rev_parse(i, ["HEAD"])
        remote_ref = git.rev_parse(i, ["@{u}"])

        if not remote_ref or local_ref == remote_ref:
            print("Already up to date.")
        else:
            print("\n{}".format("=" * cols))
            git.pull(i)
            print("{}".format("=" * cols))


if __name__ == "__main__":
    main()
